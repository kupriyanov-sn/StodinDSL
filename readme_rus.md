# Stodin DSL

Оглавление
 1. Пример кода.
 2. Особенности Stodin DSL.
 3. Особенности синтаксиса и семантики.
 4. Переменные и стандартные типы.
 5. Функции.
 6. Операторы ветвления.
 7. Циклы.
 8. Константы и перечисления (enum).
 9. Структуры.
 10. Стандартные контейнеры.
 11. Исключения и утверждения.
 12. Модули.
 13. Особенности работы компилятора (транслятора).
 14. Стандартная библиотека.
 15. Развитие.

## 1. Пример кода.

В данной главе приводится код математического тренажёра, написанный на языке Stodin DSL, для демонстрации синтаксиса. 

```python
import random
import time

def get_multi_question
    mref a:int b:int answer:int 
    *v @array|int
    for a in 12; 99; 1
        *c @int a % 10
        if != c 0
            v @add a
    a @random:choice v
    b @random:randint 3 9
    answer = a * b

def math_round
    mref res:bool
    *tAllStart @int @time:time
    *counter @int 0
    for
        *tStart @int @time:time
        *a; *b; *answer @int 0
        a b answer @get_multi_question
        *strAnswer @string @to_string answer
        @print* a " * " b "\n"
        *strRes @string @getline
        if strRes "q"
            res = false
            return
        if strRes strAnswer
            @print "True\n"
            counter + 1
        else
            @print* "False! Correct answer is: " answer "\n"
        *tEnd @int @time:time - tStart
        @print* "t = " tEnd "\n"
        if counter 6
            break
    *tAllEnd @int @time:time - tAllStart
    *speed @double tAllEnd$double / counter
    @print* "speed: " speed "\nEnter to proceed or q to quit: \n"
    *key @string @getline
    res != key "q"

def main
    @print "\nInput an answer or q to quit: \n"
    for *b @bool in b @math_round
        for 0
```

Информация для сборки этого и других примеров приведена в главе 13 (особенности работы компилятора). 
 2. Особенности Stodin DSL.
Stodin DSL имеет следующие особенности:

1. Язык простой и лаконичный. При этом разбор кода прост как для человека, так и для программных анализаторов.
2. Язык статически типизированный.
3. Позволяет включать и отключать дополнительные возможности для отладки и повышения надёжности: подробный вывод исключений (stack trace), детектирование переполнения переменных (целочисленных и с плавающей запятой), детектирование деления на ноль и т. д.
4. Стандартная библиотека разрабатывается с использованием в качестве образцов библиотеки Python или C#.
5. Stodin DSL создаётся как инструмент ускорения разработки программ на C++. Поэтому он взаимодействует с кодом C++: транслируется в него, использует его исполнимые файлы, использует конструкции, которые сам не может создать по причине простоты и лаконичности.

Хотя Stodin во многих случаях может заменить язык общего назначения, он ближе к предметно-ориентированным языкам (DSL) по следующим причинам:

1. Используются особенности, применяемые в DSL: цепочечный синтаксис, отсутствие выделяемых скобками блоков кода, трансляция в другой язык программирования. 
2. Stodin имеет ряд ограничений, введённых для простоты, лаконичности и снижения вероятности частого изменения синтаксиса:

* Язык не имеет системы приоритетов.
* Язык полностью свободен от скобок: круглых, квадратных, фигурных, угловых, а также от слов их заменяющих (begin, end). 
* У Stodin DSL нет возможностей метапрограммирования. В том числе нет возможности разработки шаблонов в стиле C++, хотя доступна настройка типа шаблонов из библиотек.
* Нет возможностей для функционального программирования.
* Нет возможности создавать полноценные собственные классы с наследованием, инкапсуляцией и полиморфизмом, хотя можно использовать классы из библиотек.
* Нет специального unsafe режима. Вместо этого используется подключение файлов с кодом на языке C++.
* Не требует управления памятью. Забота о выделении и освобождении памяти передаётся в библиотеки.
       
Ограничения Stodin позволили ему приблизиться по лаконичности к языку Python, несмотря на наличие статической типизации. Если на относительно маленьких программах код Stodin по символам больше кода Python (примерно в 1,5 раза), то на средних и крупных может сравняться и даже  стать меньше. Python достигает лаконичности за счёт хитроумных конструкций, которые очень сложно равномерно распределить по всему коду. Stodin же просто экономит на скобках и использует цепочечный синтаксис, в результате чего достигается соизмеримая лаконичность без дополнительных трудозатрат.

##3. Особенности синтаксиса и семантики.

Если бегло ознакомиться с примером из главы 1, то можно предположить, что синтаксис Stodin близок к синтаксису Python. На самом же деле общим у этих языков является только система с отступами (в Stodin отступ всегда 4 пробела, в отличии от Python), а также некоторые ключевые слова. Основные отличия от большинства современных языков (кроме тех, что упомянуты в главе 1) заключаются в следующем:

1. Функции не имеют возвращаемых значений. Вместо них используются ссылки. 
2. В аргументах функции используются только константные и изменяемые ссылки.
3. Используется цепочки функций, изменяющих данные.
4. Присваивание переменных меняет значение, а не ссылку.
5. Нет скрытых переменных (следствие отсутствия скобок и приоритетов).

Наиболее интересным является цепочечный синтаксис, позволяющий писать код типа:
```
person @wake_up @put_on coat; hat @go_to nearest shoop @buy apples; eggs; bread
```
Здесь функции (начинающиеся с символа @) последовательно выполняют операции над переменной person. На других языках этот код мог бы выглядеть так:

```python
person.wake_up()
person.put_on(coat)
person.put_on(hat) 
person.go_to(nearest, shoop)
person.buy(apples)
person.buy(eggs)
person.buy(bread)
```
В данном случае соотношение кода в символах 133 / 79 = 1,68, а читаемость даже повышается. В других языках можно достигнуть близкого эффекта, если в каждом методе возвращать ссылку на объект. Но и в этом случае покупка продуктов (apples; eggs; bread) всё равно потребует три раза написать buy. Кроме того, в Stodin этот прием распространяется и на операторы:
```
a + b c d
```
В данном случае к переменной a последовательно прибавляются переменные b, c, d.

Последовательность вычисления операторов подобна работе с калькулятором: вначале ставится изменяемая переменная, затем оператор, затем цепочка неизменяемых переменных. Эквивалентом выражения выше в коде на C++ будет:

```c++
a += b; a += c; a += d;
```
Для операторов сравнения требуется дополнительные средства, чтобы следующее звено не перекрыло эффект от работы предыдущего:
```
res > u1 u2 ? u2 u3 ? u3 u4
```
Здесь в переменную res последовательно помещается результаты сравнения, пока они верны.
```
res == u1 56 !? u2 26 !? u3 10 !? u4 5
```
Здесь в переменную res последовательно помещается результаты сравнения, пока они не верны. Допустима и такая форма:
```
res? == u3 3
```
Здесь выражение будет вычисляться, если переменная res равна true.
 
На практике цепочки используются не очень часто, обычно в арифметических выражениях или в функциях типа @print.

## 4. Переменные и стандартные типы.

Создание переменной помечается символом *, а затем следует её тип и значение: 
```
*a @int 5
```
Создание переменной может сочетаться с цепочной:
``` 
*sz @int @size arr + 15
```
На момент написания документации вывода типов нет (за исключением обхода элементов массива в цикле). Реализовать его не очень сложно, но нет уверенности, что это не усложнит работу анализаторам кода.

Переменные в коде на языке Stodin (в отличие от констант) могут создаваться только внутри функций. Если для какой-то внешней библиотеки на C или C++ требуется глобальная переменная, то рекомендуется в этой библиотеке её и создать. 
 
Стандартные типы, не требующие подключения модулей, приведены в таблице ниже:
 

|Тип Stodin  |     Тип C++     |            Комментарий              |
|:----------:|:---------------:|:-------------------------------:|
| uint       | uint64_t        |                                 |
| int        | int64_t         |                                 |
| u64        | uint64_t        |                                 |
| i64        | int64_t         |                                 |
| u8         | uint8_t         |                                 |
| i8         | int8_t          |                                 |
| u16        | uint16_t        |                                 |
| i16        | int16_t         |                                 |
| u32        | uint32_t        |                                 |
| i32        | int32_t         |                                 |
| double     | double          |                                 |
| float      | float           |                                 |
| ldouble    | long double     |                                 |
| string     | __stodin_string | Класс-обёртка для std::string   |
| bool       | bool            |                                 |
| array      | __stodin_array  | Класс-обёртка для std::vector   |
| dict       | __stodin_dict   | Класс-обёртка для std::map      |
| file       | __stodin_file   | Класс-обёртка для std::iostream |

Классы-обертки нужны для того, чтобы преобразовать возвращаемые значения в ссылки.
Преобразование типов производится с помощью значка $:

```python
*u3 @int 10
*d @double u3$double / 3.3
res @math:float_compare d 3.03 0.01
u3 = d$int
res? == u3 3
```

##  5. Функции.

Заголовок функции пишется в общем случае в три строки, с использованием ключевых слов: def, mref, cref. После def следует имя функции, после  mref список ссылок на изменяемые переменные (аккумуляторы) с типами, после cref – константные ссылки с типами. При использовании функции аккумуляторы пишутся слева заголовка, константные ссылки — справа. Например:

```python
def double_add
    mref a:int b:int
    cref c:int
    a + c
    b + c

a b @double_add c
```
Применение функций приведено в главах 1, 3. Кроме того, есть дополнительные возможности:
1. Если функция принимает один константный параметр,  то можно пометить её звёздочкой, чтобы не писать символ ; после каждого аргумента, например:
```
a b @double_add* c d e f
@print* a b c "\n"
```
2. Как и для операторов сравнения, в цепочках функций можно использовать разделитель «?» или «!?».
3. Для создания инкапсулированных функций достаточно перед заголовком поставить подчёркивание: `def _double_add`
Инкапсулированные функции должны быть размещены выше места их использования. Открытые функции могут располагаться везде.

##  6. Операторы ветвления.

Для ветвления используются следующие ключевые слова: if, ifnot, elif, else. В простейшем случае код с операторами ветвления будет иметь вид:

```python
if someVar
    @do_something_1
elif anotherVar
    @do_something_2
else
    @do_something_3
```
Так как значения из функций не возвращаются, а создаются, то имеются некоторые особенности применения этих операторов. Произвольное выражение в операторе ветвления использовать нельзя. Вместо этого предусмотрены 6 интуитивно понятные форм:

```python
if a # with ifnot
if a b # without ifnot
if > a b # without ifnot
if a in b c d # with ifnot
if a in someArray # with ifnot
if *a @bool in a @some_func b c # with ifnot
```
Реализовать применение выражений-цепочек можно было бы с помощью внешних переменных, либо с помощью лямбды с замыканием. Но применение цепочек усложняет анализ кода при создании тестов, так как тесты должны проходить по всем ветвям.

Оператор ifnot потребовался для изменения оценки переменной оператора на инвертированную. Для последних трёх форм оператора if это затруднительно сделать простым инвертированием переменной a. 

## 7. Циклы.

В языке Stodin есть только один оператор для циклов, у которого имеется набор вариантов:

```python
for
for 0
for 1
for n
for *i in 10;0;-1   
for *i @uint in 10;0;-1   
for *a in v
for *a in b c d
for *b @bool in b @some_func c
```

`for` без параметров задаёт бесконечный цикл.
`for 0` является пустым оператором.
`for 1` определяет блок кода у которого могут быть свои локальные переменные.
`for n` задаёт цикл исполняющийся n раз.
`for *i in begin;end;step` задает цикл в котором переменная i изменяется от переменной (константы) begin до переменной (константы) end с шагом step.
`for *i @uint in 0;10;1` задает цикл в котором переменная i заданного типа изменяется от переменной (константы) begin до переменной (константы) end с шагом step.
`for *a in v` задаёт цикл, в котором переменная a меняется в соответствии со значениями массива v.
`for *a in b c d`  задаёт цикл, в котором переменная a обходит список переменных. 
`for *b @bool in b @some_func c` задаёт цикл, который выполняется пока переменная b равна true. Значение переменной определяется функцией `@some_func`.

## 8. Константы и перечисления (enum).

Объявления констант приведены ниже:

```
const CNST_1 @int 5
const VCNST @array|int 4 8 14
const _CNST_2 @int 15
```
The declaration of constants begins with the const keyword, then comes the name of the constant, the type of constant, initializing the value (or a list of values). A constant can be a simple type, a string type, an array. The underscore in the first character makes the constant local in the current module.
Announcement listings are listed below: 

```
enum symbols @u8 A=5 B C D
enum _symbols2 @u8 A B C D
```
Объявление констант начинается с ключевого слова const, затем идёт имя константы, тип константы, инициализирующее значение (либо список значений). Константа может быть простого типа, строкового типа, массивом. Подчёркивание в первом символе делает константу локальной в текущем модуле.
Объявление перечислений приведены ниже: 

```
*enumD @symbols symbols^D
res == enumD symbols^D
res == enumD$int 8
```

##  9. Структуры.

Примеры структур приведены ниже:

```python
struct OpenStruct
    *i1 @int 1
    *s2 @string "2"
    *arr @array|string "3" "4"

struct _StaticStruct
    *s1 @string "static"
```
труктуры в Stodin не имеют функций, используются только для хранения данных. При создании поля структуры инициализируются значениями, указанными в описании структуры.  Кроме того, структуры, не имеющие вложенных структур и контейнеров (кроме string) могут быть инициализированы списком значений на этапе создания переменной:

```python
struct OpenStruct2
    *s1 @string "1"
    *s2 @string "1"
    *s3 @string "1"
    *s4 @string "1"

*os2 @OpenStruct2 "6" "7" "8" "9"
```

Структура, тип которой начинается подчёркивания, доступна только в модуле, в котором она объявлена.

### 10. Стандартные контейнеры.

В Stodin есть три стандартных контейнера, не требующих подключения модулей: строка, массив и словарь. 
Массив создаётся следующим образом:

`*v @array|uint 1 2 4`

Здесь имя массива состоит минимум из двух частей, разделённых символом |. За именем следует инициализирующий список, задающий количество и значение элементов массива. 
Обращение к элементу массива может быть следующим:

`v|0 + 5`

Здесь к нулевому элементу массива прибавляется число 5.

Массив может иметь и более сложную структуру:

`*aIntInt @array|array|int @resize 3 `

Это массив массивов. Инициализировать простыми значениями его при создании нельзя. Только списком уже созданных массивов. Задать его размер можно с помощью функции @resize. Кроме того, заполнять массив массивов (как и просто массив) можно так:

`aIntInt|* = 4 5 6 `

Данная конструкция создаёт новый элемент массива с помощью списка значений. Если продолжить это выражение цепочкой функций, то она будет изменять этот последний элемент массива. 
Словари создаются так:

`*m @dict|uint,string @add 1 "1" ; 2 "2" ; 3 "3"`


То есть, после знака | требуется указать пару типов для ключа-значения через запятую без пробелов. Словарь не может быть инициализирован простыми значениями при создании. Поэтому в приведённом примере используется функция `@add`. 
Обращаться к элементу словаря можно также, как и к элементу массива. Обойти элементы словаря, который мы создали выше, можно так:

```python
for *b in m
    *s @string @to_string b.first     
    res? == s b.second
```
Заполнять словарь можно следующим способом:

```python
*tests @dict|string,bool
tests|*"array test" @test_array
tests|*"bitwise operators test" @test_bitwise_operators
tests|*"bool test" @test_bool
```
Для словаря важен такой способ заполнения, ибо в Stodin элемент словаря не создаётся автоматически в момент обращения по ключу, которого нет в словаре (как это реализовано в C++, C#, Python). Если мы обращаемся по ключу, которого нет в словаре без использования символа *, то будет выдано исключение. Таким образом исключается случайное создание нового элемента.
Можно использовать и словари словарей:

```python
*ssDict @dict|string,dict|string,int
*sDict @dict|string,int @add "1" 1; "2" 2; "3" 3
ssDict @add "01" sDict; "02" sDict; "03" sDict
ssDict|*"04" @add "4" 4
ssDict|"04"|*"5" = 5
```
Славарь словарей имеет сложно читаемый тип. Для упрощения можно использовать оператор typedef:

`typedef dict|string,int dctStr`
`*ssDict @dict|string,dctStr`

Использование строки в Stodin почти не отличается от использования std::string. Единственное отличие в том, что в Stodin нет отдельных кавычек для символа. Каждый односимвольный литерал в двойных кавычках при трансляции преобразуется в символ.
Строки состоят из байтов, имеют кодировку utf-8 (зависит от редактора). Соответственно, определённая буква может содержать неопределённое число байт. Пока не предусмотрены средства для удобной работы с символами, входящих в алфавиты типа кириллицы. 
Все методы для работы со строкой, массивом, словарём в классах-обёртках, в библиотеке, написанной на C++, вынесены во friend функции, чтобы можно было пользоваться цепочками.

##  11. Исключения и утверждения.

Пример использования исключений приведён ниже:

```python
*arr @array|int 1 2 3 4
try
    arr|12 = 3
catch out_of_range e
    @print* e "\n"
res = false
try
    throw domain_error "test domain_error"
catch domain_error e
    @print* e "\n"
try
    assert > 1 2
catch logic_error e
    @print* e "\n"
```
То есть используются три традиционно используемых ключевых слова: try, catch, throw, и типы исключений из библиотеки exception языка C++. Кроме того, используется утверждение (assert) как способ генерации исключения типа logic_error при выполнении определённого условия. Формат assert соответствует формату if (без ifnot).
В отличии от кода C++, в Stodin всегда генерируется исключение при выходе за границы стандартных массива, строки, словаря.
По умолчанию в Stodin не генерируются исключения при делении на ноль или переполнении. Для включения режима, когда такие исключения генерируются, требуется использовать ключ -safe.
По умолчанию в Stodin не производится подробный вывод исключений (stack trace). Для включения этого режима используется флаг -trace. У данного режима есть некоторые ограничения: исключения не перехватываются в месте создания переменной и операторах типа if и for. Соответственно, они будут перехвачены чуть выше места возникновения ошибки (в функции, которая использует функцию с не перехваченным исключением).

## 12. Модули.
 
Модули в Stodin разделяются на локальные и библиотечные. Локальные разделяются на модули, написанные на  Stodin и модули, написанные на C++. Библиотечные модули все представляют собой код на C++, даже если изначально они были написаны на Stodin, а затем транслированы в код на C++. Каждый модуль содержит уникальное пространство имён, связанное с именем файлов модуля.
Подключение модулей имеет вид:

```python
import time
import math
import ^ math
import ^ structs
import ^cpp local_test
```
Здесь ^hinter и ^scorer – имена модулей, set_word и update_time — функции из модулей. Для библиотечных модулей значок ^ не требуется. Данное разделение основано на опыте работы с модулями языка Python, в котором могут быть коллизии, связанные с совпадением имён локальных и библиотечных модулей.

Локальный модуль, написанный на C++ может состоять из одного заголовочного файла, либо из заголовочного и исполнимого файла. Код таких модулей должен находиться в пространстве имён, начинающийся с приставки _stodin_module_, за которой следует имя файла без расширения. Пример кода такого модуля приведён ниже:
```
game.hinter @^hinter:set_word wordPair.answer
game.scorer @^scorer:update_time
```
Here ^hinter and ^scorer are the names of the modules, set_word and update_time are functions from the modules. For library modules, the ^ sign is not required. This separation is based on experience with Python modules, in which there may be conflicts associated with the coincidence of the names of local and library modules. 

A local module written in C++ can consist of a single header file, or a header and executable file. The code of such modules should be in the namespace, starting with the _stodin_module_ prefix, followed by the file name without the extension. The code example of such a module is given below:
```c++
#ifndef _STODIN_MODULE_LOCAL_TEST_H
#define _STODIN_MODULE_LOCAL_TEST_H

#include <iostream>

namespace _stodin_module_local_test
{
    inline void test(bool & res){res = true;}
}

#endif // _STODIN_MODULE_LOCAL_TEST_H
```
При создании классов в модулях, написанных на C++, все методы класса должны быть вынесены во friend-функции.

## 13.  Особенности работы компилятора (транслятора).

Компилятор не требует какого-либо файла проекта. Вместо этого он последовательно подключает модули, указанные в модулях, которые он уже подключил, начиная от главного локального модуля, имя которого передано компилятору.
Все транслируемые файлы помещаются в директорию «stodin-out», которая создаётся в директории, где расположен главный модуль. Туда же помещаются все необходимые библиотечные файлы и автоматически созданный make-файл. Затем с помощью make-файла создаётся исполнимый файл, который помещается рядом с главным модулем и имеет его имя.

Компилятор имеет флаги:

-run : запустить скомпилированный файл.
-r  : перекомпилировать проект целиком. 
-trace : подробный вывод исключений (stack trace).
-safe : детектирование переполнения переменных.
Таким образом вызов компилятора может иметь вид:
	compile_file_path main.stdn -r -trace -safe -run
где compile_file_path - путь к файлу компилятора;
	main - имя главного модуля.

Для корректной работы компилятора Stodin на компьютере должны быть установлены:
1. Компилятор C++ (g++ или MinGW), поддерживающий c++14.
2. Утилита Make (gcc-make, mingw32-make).
3. Стандартная библиотека Stodin (поставляется с компилятором).

Пути к компилятору, сборщику и директориям должны быть указаны в файле config.cfg, который расположен рядом с исполнимым файлом компилятором. Пример настроек этого файла приведён ниже:
COMPILER_PATHS=.;C:\MinGW\bin;C:\MinGW;
CC="C:\MinGW\bin\g++.exe"
MAKE="C:\MinGW\bin\mingw32-make.exe"
LIB=D:\stodin\stodin-lib\

Описание этих настроек:
COMPILER_PATHS – пути, необходимые для компилятора C++.
CC – путь к компилятору C++.
MAKE – путь к сборщику.
LIB – путь к стандартной библиотеке Stodin.

## 14.  Стандартная библиотека.

Подробное описание стандартной библиотеки будет сделано в отдельном документе. На момент написания этой документации разрабатываются следующие модули стандартной библиотеки, требующие импорта:
fileinfo — функции для работы с файлами и директориями.
math — математические функции.
random — функции для генератора случайных чисел, случайного выбора, перемешивания.
time — функции для определения времени.
exstr — дополнительные функции для работы со строкой.
	
Также многие функции реализованы в модулях, которые не требуют импорта:
array — работа с массивами.
common — различные функции, например, работа с аргументами main.
dict — работа со словарями.
file — работа с файлами.
io — работа с вводом и выводом.
safe — безопасные математические операторы (для режима -safe).
string — работа со строкой.

## 15.  15. Развитие.

На данный момент не планируются значительные изменения синтаксиса. Единственная вещь, которая явна необходима на данные момент — реализация синтаксиса для подключения пакетов модулей и скомпилированных библиотек (dll или so). Кроме того, возможно, потребуется какой-то дополнительный синтаксис, если будет реализована работа с потоками.
Для дальнейшего развития требуются следующие разработки:

1. Добавление модулей к стандартной библиотеке (и дополнение существующих).
2. Создание анализаторов кода.
3. Разработка проектов на языке Stodin.

Возможно, в стандартную библиотеку  Stodin будут добавлены:

1. Модуль работы со строками, состоящих из графем, с доступом по индексу к графему, а к байту. Такие строки были бы удобны при обработке текста не на английском языке.
2. Модули для обработки файлов с текстовыми данными, типа json или xml.
3. Модуль обработки изображений. Возможно, тут подойдет взаимодействие с OpenCV.
4. Модуль для вывода графики. Возможно, тут подойдет взаимодействие с SDL.
5. Модуль для работы с портами ввода-вывода, типа RS-232 или USB HID.

Модули для работы с сетью, с GUI, с базами данных, шифрованием данных и т. д. пока не планируется разрабатывать по причине ограниченных возможностей автора. 
Анализаторы кода могут использоваться, например, для генерации оптимального числа тестов на основе подсчёта операторов ветвления и анализа использования побочных эффектов.
